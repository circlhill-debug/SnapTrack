<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SnapTrack — USPS OCR</title>

  <!-- Basic CSP: allows our code + jsDelivr for Tesseract, blocks framing -->
 <meta http-equiv="Content-Security-Policy"
      content="default-src 'self';
               img-src 'self' blob:;
               script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net;
               connect-src 'self';
               style-src 'self' 'unsafe-inline';
               frame-ancestors 'none'">

  <style>
    :root{--ink:#111;--muted:#6b7280;--line:#e5e7eb;--bg:#f8fafc}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial}
    .wrap{max-width:720px;margin:0 auto;padding:20px}
    h1{font-size:1.75rem;margin:0 0 .25rem}
    p{margin:.25rem 0}
    .card{background:#fff;border:1px solid var(--line);border-radius:16px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
    button{cursor:pointer;border:1px solid #d1d5db;background:#fff;padding:10px 14px;border-radius:12px}
    button.primary{background:#111;color:#fff;border-color:#111}
    button:active{transform:scale(.99)}
    .muted{color:var(--muted)}
    .grid{display:grid;gap:16px}
    .img{width:100%;border:1px solid var(--line);border-radius:12px;touch-action:none}
    .bar{height:8px;border-radius:999px;background:#eef2f7;overflow:hidden}
    .bar>div{height:100%;background:#111;width:0%}
    textarea{width:100%;height:150px;border:1px solid var(--line);border-radius:12px;padding:10px;background:#f7f7f8;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;font-size:.9rem}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
    .pill{display:inline-block;font-size:.75rem;padding:.25rem .5rem;border-radius:999px;border:1px solid #d1d5db}
    label.switch{display:flex;align-items:center;gap:.5rem;font-size:.9rem}
    .list > button{width:100%;text-align:left}
    .good{background:#ecfdf5;border-color:#a7f3d0}
    .bad{background:#fef2f2;border-color:#fecaca;color:#b91c1c}
    footer{margin-top:16px;color:#6b7280;font-size:.85rem;text-align:center}
  </style>
</head>
<body>
  <div class="wrap">
    <header style="margin-bottom:16px">
      <h1>SnapTrack — USPS OCR</h1>
      <p class="muted">Snap or upload a USPS label. A crop box appears immediately—drag it, resize corners/edges, then tap <em>Use crop</em>.</p>
    </header>

    <div class="grid">
      <!-- 1) Capture / Upload -->
      <section class="card">
        <div style="display:flex;justify-content:space-between;gap:12px;align-items:center;flex-wrap:wrap">
          <div>
            <h3 style="margin:.25rem 0">1) Take or upload a photo</h3>
            <p class="muted" style="margin:0">Rear camera in good light; fill the frame. Or upload and crop first.</p>
          </div>
          <div style="display:flex;gap:8px;flex-wrap:wrap">
            <button id="snapBtn">Snap (Camera)</button>
            <button id="uploadBtn">Upload from Photos</button>
          </div>
        </div>

        <input id="fileSnap"   type="file" accept="image/*" capture="environment" style="display:none" />
        <input id="fileUpload" type="file" accept="image/*" style="display:none" />

        <!-- Preview + Crop UI -->
        <div id="previewWrap" style="margin-top:12px;display:none">
          <canvas id="canvas" class="img"></canvas>
          <div style="display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; align-items:center">
            <button id="useCrop" class="primary">Use crop</button>
            <button id="useFull">Use full image</button>
            <span class="muted" style="font-size:.9rem">Drag inside to move; drag corners/edges to resize.</span>
          </div>
        </div>

        <!-- Progress + Errors -->
        <div id="progWrap" style="margin-top:12px;display:none">
          <div class="muted" style="font-weight:600;margin-bottom:6px">
            Reading text… <span id="pct">0</span>%
          </div>
          <div class="bar"><div id="bar"></div></div>
        </div>
        <div id="err" class="card bad" style="margin-top:12px;display:none"></div>
      </section>

      <!-- 2) Candidates + Manual -->
      <section class="card">
        <div style="display:flex;justify-content:space-between;gap:12px;align-items:center">
          <div>
            <h3 style="margin:.25rem 0">2) Candidates found</h3>
            <p class="muted" style="margin:0">Tap a number to open USPS in a new tab.</p>
          </div>
          <label class="switch">
            <input type="checkbox" id="autoOpen" checked />
            <span class="pill">Auto-open if only one</span>
          </label>
        </div>

        <div id="best" class="card good" style="margin-top:12px;display:none">
          <div class="muted" style="font-size:.75rem;font-weight:700;text-transform:uppercase;margin-bottom:4px">Best match</div>
          <div id="bestNum" class="mono" style="font-size:1.15rem;word-break:break-all"></div>
          <div style="margin-top:8px;display:flex;gap:8px">
            <button class="primary" id="openBest">Open on USPS</button>
            <button id="copyBest">Copy</button>
          </div>
        </div>

        <div id="many" class="list" style="margin-top:12px;display:grid;gap:8px"></div>

        <!-- Manual Paste Box -->
        <div class="card" style="margin-top:12px">
          <h4 style="margin:.25rem 0">Manual (paste or edit)</h4>
          <div style="display:flex;gap:8px;flex-wrap:wrap">
            <input id="manualInput" class="mono" placeholder="Paste tracking number…"
                   style="flex:1;min-width:220px;padding:10px;border:1px solid var(--line);border-radius:10px" />
            <button id="openManual" class="primary">Open on USPS</button>
          </div>
          <p class="muted" style="margin:.5rem 0 0">Tip: copy from “Raw OCR” if needed.</p>
        </div>
      </section>

      <!-- 3) Raw OCR -->
      <section class="card">
        <h3 style="margin:.25rem 0">3) Raw OCR (troubleshooting)</h3>
        <p class="muted" style="margin:0 0 6px">If this looks messy, try another angle or more light.</p>
        <textarea id="raw" readonly></textarea>
      </section>

      <section class="muted" style="font-size:.9rem">
        <p><strong>Tips:</strong> Avoid glare; tilt slightly if needed. Everything runs locally—no images are uploaded.</p>
      </section>

      <footer>
        © 2025 Dave — SnapTrack v1.5 • Built for USPS label OCR
      </footer>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <script>
    // Version
    const SNAPTRACK_VERSION = "v1.5 (2025-08-25)";

    // Elements
    const fileSnap   = document.getElementById('fileSnap');
    const fileUpload = document.getElementById('fileUpload');
    const snapBtn    = document.getElementById('snapBtn');
    const uploadBtn  = document.getElementById('uploadBtn');

    const previewWrap= document.getElementById('previewWrap');
    const canvas     = document.getElementById('canvas');
    const ctx        = canvas.getContext('2d');

    const progWrap   = document.getElementById('progWrap');
    const pct        = document.getElementById('pct');
    const bar        = document.getElementById('bar');
    const err        = document.getElementById('err');

    const rawOut     = document.getElementById('raw');
    const many       = document.getElementById('many');
    const bestBox    = document.getElementById('best');
    const bestNum    = document.getElementById('bestNum');
    const openBest   = document.getElementById('openBest');
    const copyBest   = document.getElementById('copyBest');
    const autoOpen   = document.getElementById('autoOpen');

    const useCropBtn = document.getElementById('useCrop');
    const useFullBtn = document.getElementById('useFull');

    const manualInput = document.getElementById('manualInput');
    const openManual  = document.getElementById('openManual');

    // --- Crop/drag constants & state ---
    const HANDLE = 16;                 // handle square size (px)
    const MIN_W = 20, MIN_H = 20;

    let candidates = [];
    let best = null;

    let originalImg = null;            // ImageBitmap
    let displayScale = 1;              // canvas pixels per image pixel
    let cropRect = null;               // {x,y,w,h}
    let isDragging = false;

    let dragMode = null;               // 'move' | corner/edge | null
    let dragStart = null;              // {x,y}
    let startRect = null;              // snapshot of rect

    // Events
    snapBtn.addEventListener('click',   () => fileSnap.click());
    uploadBtn.addEventListener('click', () => fileUpload.click());
    fileSnap.addEventListener('change', onFile);
    fileUpload.addEventListener('change', onFile);

    useCropBtn.addEventListener('click', async () => {
      if (!originalImg) return;
      const region = validCrop() ? cropFromCanvas() : makeDownscaledCanvas(originalImg);
      await ocrCanvas(region);
    });
    useFullBtn.addEventListener('click', async () => {
      if (!originalImg) return;
      await ocrCanvas(makeDownscaledCanvas(originalImg));
    });

    openBest.addEventListener('click', () => { if (best) openUSPS(best); });
    copyBest.addEventListener('click', async () => { if (best) await navigator.clipboard.writeText(best); });

    openManual.addEventListener('click', () => {
      const val = (manualInput.value || '').trim().toUpperCase();
      if (!val) return;
      const cleaned = /^[A-Z]{2}\d{9}US$/i.test(val) ? val : val.replace(/\D+/g,'');
      if (!cleaned) return;
      openUSPS(cleaned);
    });

    // File handling
    async function onFile(e){
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      resetUI();

      const url = URL.createObjectURL(f);
      try {
        originalImg = await createImageBitmap(await fetch(url).then(r=>r.blob()));
        setupCanvasForImage(originalImg);
        previewWrap.style.display = '';
      } catch(ex){
        err.textContent = 'Could not load image. Try another photo.';
        err.style.display = '';
      } finally {
        URL.revokeObjectURL(url);
      }
    }

    // Canvas / crop
    function setupCanvasForImage(img) {
      const maxW = Math.min(1200, Math.max(360, Math.floor(window.innerWidth - 40)));
      const scale = Math.min(1, maxW / img.width);
      canvas.width = Math.round(img.width * scale);
      canvas.height = Math.round(img.height * scale);
      displayScale = scale;

      setDefaultCrop();
      drawCanvas();
      attachCropEvents();
    }

    function setDefaultCrop(){
      const w = Math.round(canvas.width * 0.92);
      const h = Math.round(canvas.height * 0.28);
      cropRect = {
        x: Math.round((canvas.width - w) / 2),
        y: Math.round((canvas.height - h) / 2),
        w, h
      };
    }

    // OUTLINE + HANDLE rendering
    function drawCanvas() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (!originalImg) return;

      // Photo
      ctx.drawImage(originalImg, 0, 0, originalImg.width*displayScale, originalImg.height*displayScale);

      if (cropRect) {
        ctx.save();
        // double-stroke outline (dark under, white on top)
        ctx.strokeStyle = 'rgba(0,0,0,0.9)';
        ctx.lineWidth = 5;
        ctx.strokeRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.strokeRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);

        // handles
        const handles = handlePositions(cropRect);
        for (const h of handles) {
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(h.x - HANDLE/2, h.y - HANDLE/2, HANDLE, HANDLE);
          ctx.strokeStyle = 'rgba(0,0,0,0.9)';
          ctx.lineWidth = 2;
          ctx.strokeRect(h.x - HANDLE/2, h.y - HANDLE/2, HANDLE, HANDLE);
        }
        ctx.restore();
      }
    }

    function handlePositions(r){
      const cx = r.x + r.w/2, cy = r.y + r.h/2;
      return [
        {name:'nw', x:r.x,       y:r.y},
        {name:'n',  x:cx,        y:r.y},
        {name:'ne', x:r.x+r.w,   y:r.y},
        {name:'e',  x:r.x+r.w,   y:cy},
        {name:'se', x:r.x+r.w,   y:r.y+r.h},
        {name:'s',  x:cx,        y:r.y+r.h},
        {name:'sw', x:r.x,       y:r.y+r.h},
        {name:'w',  x:r.x,       y:cy},
      ];
    }

    function attachCropEvents(){
      canvas.onpointerdown = (ev) => {
        ev.preventDefault();
        const p = canvasPoint(ev);
        dragStart = p;
        startRect = cropRect ? {...cropRect} : null;

        const hit = hitTest(p, cropRect);
        if (hit) {
          dragMode = hit;         // 'move' or a handle name
        } else {
          // NO AUTO-RESET: if click outside, do nothing (keep current rect)
          dragMode = null;
          isDragging = false;
          return;
        }

        isDragging = true;
        canvas.setPointerCapture(ev.pointerId);
        drawCanvas();
      };

      canvas.onpointermove = (ev) => {
        if (!isDragging || !cropRect || !dragMode) return;
        const p = canvasPoint(ev);
        const dx = p.x - dragStart.x;
        const dy = p.y - dragStart.y;

        if (dragMode === 'move' && startRect) {
          cropRect.x = clamp(0, startRect.x + dx, canvas.width - startRect.w);
          cropRect.y = clamp(0, startRect.y + dy, canvas.height - startRect.h);
        } else if (startRect) {
          // Resize from a handle
          resizeFromHandle(dragMode, startRect, dx, dy);
        }

        // Enforce min size & bounds
        if (cropRect.w < MIN_W) cropRect.w = MIN_W;
        if (cropRect.h < MIN_H) cropRect.h = MIN_H;
        if (cropRect.x < 0) cropRect.x = 0;
        if (cropRect.y < 0) cropRect.y = 0;
        if (cropRect.x + cropRect.w > canvas.width)  cropRect.x = canvas.width  - cropRect.w;
        if (cropRect.y + cropRect.h > canvas.height) cropRect.y = canvas.height - cropRect.h;

        drawCanvas();
      };

      canvas.onpointerup = (ev) => {
        isDragging = false;
        dragMode = null;
        canvas.releasePointerCapture(ev.pointerId);
        drawCanvas();
      };
    }

    function hitTest(p, r){
      if (!r) return null;
      // handles first
      for (const h of handlePositions(r)) {
        if (Math.abs(p.x - h.x) <= HANDLE/2 && Math.abs(p.y - h.y) <= HANDLE/2) return h.name;
      }
      // inside rect
      if (pointInRect(p, r)) return 'move';
      return null;
    }

    function pointInRect(p, r){
      return p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h;
    }

    function resizeFromHandle(mode, r0, dx, dy){
      let x = r0.x, y = r0.y, w = r0.w, h = r0.h;

      const left   = () => { x = clamp(0, r0.x + dx, r0.x + r0.w - MIN_W); w = (r0.x + r0.w) - x; };
      const right  = () => { w = clamp(MIN_W, r0.w + dx, canvas.width - r0.x); };
      const top    = () => { y = clamp(0, r0.y + dy, r0.y + r0.h - MIN_H); h = (r0.y + r0.h) - y; };
      const bottom = () => { h = clamp(MIN_H, r0.h + dy, canvas.height - r0.y); };

      if (mode.includes('w')) left();
      if (mode.includes('e')) right();
      if (mode.includes('n')) top();
      if (mode.includes('s')) bottom();

      cropRect.x = Math.round(x);
      cropRect.y = Math.round(y);
      cropRect.w = Math.round(w);
      cropRect.h = Math.round(h);
    }

    function clamp(min, v, max){ return Math.max(min, Math.min(max, v)); }

    function canvasPoint(ev){
      const r = canvas.getBoundingClientRect();
      const x = (ev.clientX - r.left) * (canvas.width / r.width);
      const y = (ev.clientY - r.top)  * (canvas.height / r.height);
      return { x: Math.max(0, Math.min(canvas.width,  x)),
               y: Math.max(0, Math.min(canvas.height, y)) };
    }

    function validCrop(){ return cropRect && cropRect.w >= MIN_W && cropRect.h >= MIN_H; }

    // OCR
    async function ocrCanvas(srcCanvas){
      try {
        err.style.display = 'none';
        progWrap.style.display = '';
        pct.textContent = '0'; bar.style.width = '0%';

        const res = await Tesseract.recognize(srcCanvas, 'eng', {
          logger: m => {
            if (m.status === 'recognizing text' && typeof m.progress === 'number') {
              const p = Math.round(m.progress * 100);
              pct.textContent = String(p);
              bar.style.width = p + '%';
            }
          }
        });

        const text = (res.data.text || '');
        rawOut.value = text;

        candidates = extractUsps(text);
        renderCandidates();

        if (candidates.length === 1 && autoOpen.checked) openUSPS(candidates[0]);
      } catch(ex){
        err.textContent = 'OCR stumbled. Try a brighter, sharper photo that fills the label.';
        err.style.display = '';
      } finally {
        progWrap.style.display = 'none';
      }
    }

    // USPS + extraction (unchanged)
    function openUSPS(n){
      const url = new URL('https://tools.usps.com/go/TrackConfirmAction');
      url.searchParams.set('tLabels', n);
      window.open(url.toString(), '_blank', 'noopener,noreferrer');
    }

    function human(n){
      if (/^[A-Z]{2}\d{9}US$/i.test(n)) return n.toUpperCase();
      return n.replace(/(\d{4})(?=\d)/g, '$1 ').trim();
    }

    function score(n){
      let s = 0; const L = n.length;
      if (L === 22) s += 6;
      else if (L === 20) s += 5;
      else if (L >= 26 && L <= 34) s += 2;
      if (/^(92|93|94)/.test(n)) s += 3;
      if (/^[A-Z]{2}\d{9}US$/i.test(n)) s += 7;
      return s;
    }

    function extractUsps(text){
      const cleaned = normalize(text);
      const intl = Array.from(cleaned.matchAll(/\b([A-Z]{2})\s*(\d{3})\s*(\d{3})\s*(\d{3})\s*(US)\b/gi))
        .map(m => (m[1] + m[2] + m[3] + m[4] + m[5]).toUpperCase());
      const longNums = Array.from(cleaned.matchAll(/((?:\d[\s-]?){20,34})/g))
        .map(m => m[0].replace(/[\s-]/g,''))
        .filter(n => [20,22,26,30,34].includes(n.length));
      const seen = new Set(), out = [];
      [...intl, ...longNums].forEach(n => { if(!seen.has(n)){ seen.add(n); out.push(n); }});
      return out;
    }

    function normalize(text){
      let t = (text || '').toUpperCase();
      t = t.replace(/(?<=\d|\s)O(?=\d|\s)/g,'0');
      t = t.replace(/(?<=\d|\s)[IL](?=\d|\s)/g,'1');
      t = t.replace(/(?<=\d|\s)S(?=\d|\s)/g,'5');
      t = t.replace(/(?<=\d|\s)B(?=\d|\s)/g,'8');
      t = t.replace(/(?<=\d|\s)Z(?=\d|\s)/g,'2');
      return t;
    }

    function cropFromCanvas(){
      const c = document.createElement('canvas');
      c.width = Math.round(cropRect.w);
      c.height = Math.round(cropRect.h);
      const cctx = c.getContext('2d');
      cctx.drawImage(canvas,
        Math.round(cropRect.x), Math.round(cropRect.y), Math.round(cropRect.w), Math.round(cropRect.h),
        0, 0, Math.round(cropRect.w), Math.round(cropRect.h)
      );
      return c;
    }

    function makeDownscaledCanvas(img, maxDim=1800){
      const scale = Math.min(1, maxDim / Math.max(img.width, img.height));
      const w = Math.round(img.width * scale), h = Math.round(img.height * scale);
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      const cctx = c.getContext('2d');
      cctx.drawImage(img, 0, 0, w, h);
      return c;
    }

    function resetUI(){
      err.style.display = 'none';
      many.innerHTML = '';
      bestBox.style.display = 'none';
      rawOut.value = '';
      candidates = [];
      best = null;
      cropRect = null;
      dragMode = null;
      drawCanvas();
    }

    function renderCandidates(){
      if(!candidates.length){
        many.innerHTML = '<p class="muted" style="margin:0">No tracking numbers captured yet.</p>';
        many.style.display = '';
        return;
      }
      const scored = candidates.map(n => ({n, score: score(n)})).sort((a,b)=>b.score-a.score);
      best = scored[0].n;

      bestNum.textContent = human(best);
      bestBox.style.display = '';
      manualInput.value = best;

      if(candidates.length > 1){
        many.style.display = 'grid';
        many.innerHTML = '';
        candidates.forEach((n) => {
          const b = document.createElement('button');
          b.className = 'card';
          b.textContent = human(n);
          b.onclick = () => openUSPS(n);
          many.appendChild(b);
        });
      } else {
        many.style.display = 'none';
      }
    }
  </script>

  <!--
  MIT License (recommended to also add as a separate LICENSE file in the repo)

  Copyright (c) 2025 Dave

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
  -->
</body>
</html>
