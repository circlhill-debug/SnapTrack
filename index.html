<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SnapTrack — USPS OCR</title>
  <style>
    :root{--ink:#111;--muted:#6b7280;--line:#e5e7eb;--bg:#f8fafc}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial}
    .wrap{max-width:720px;margin:0 auto;padding:20px}
    h1{font-size:1.75rem;margin:0 0 .25rem}
    p{margin:.25rem 0}
    .card{background:#fff;border:1px solid var(--line);border-radius:16px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
    button{cursor:pointer;border:1px solid #d1d5db;background:#fff;padding:10px 14px;border-radius:12px}
    button.primary{background:#111;color:#fff;border-color:#111}
    button.ghost{background:transparent}
    button:active{transform:scale(.99)}
    .muted{color:var(--muted)}
    .grid{display:grid;gap:16px}
    .img{width:100%;border:1px solid var(--line);border-radius:12px}
    .bar{height:8px;border-radius:999px;background:#eef2f7;overflow:hidden}
    .bar>div{height:100%;background:#111;width:0%}
    textarea{width:100%;height:150px;border:1px solid var(--line);border-radius:12px;padding:10px;background:#f7f7f8;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;font-size:.9rem}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
    .pill{display:inline-block;font-size:.75rem;padding:.25rem .5rem;border-radius:999px;border:1px solid #d1d5db}
    label.switch{display:flex;align-items:center;gap:.5rem;font-size:.9rem}
    .list > button{width:100%;text-align:left}
    .good{background:#ecfdf5;border-color:#a7f3d0}
    .bad{background:#fef2f2;border-color:#fecaca;color:#b91c1c}
    a.tiny{font-size:.85rem;text-decoration:underline;color:#374151}
  </style>
</head>
<body>
  <div class="wrap">
    <header style="margin-bottom:16px">
      <h1>SnapTrack — USPS OCR</h1>
      <p class="muted">Snap or upload a USPS label. A white crop box will appear—drag it quickly, tap <em>Use crop</em>, and I’ll open USPS tracking.</p>
    </header>

    <div class="grid">
      <!-- 1) Capture / Upload -->
      <section class="card">
        <div style="display:flex;justify-content:space-between;gap:12px;align-items:center;flex-wrap:wrap">
          <div>
            <h3 style="margin:.25rem 0">1) Take or upload a photo</h3>
            <p class="muted" style="margin:0">Rear camera in good light; fill the frame. Upload if you want to crop first.</p>
          </div>
          <div style="display:flex;gap:8px;flex-wrap:wrap">
            <button id="snapBtn">Snap (Camera)</button>
            <button id="uploadBtn">Upload from Photos</button>
          </div>
        </div>

        <input id="fileSnap"   type="file" accept="image/*" capture="environment" style="display:none" />
        <input id="fileUpload" type="file" accept="image/*" style="display:none" />

        <!-- Preview + Instant Crop UI -->
        <div id="previewWrap" style="margin-top:12px;display:none">
          <canvas id="canvas" class="img" style="touch-action:none"></canvas>
          <div style="display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; align-items:center">
            <button id="useCrop" class="primary">Use crop</button>
            <button id="useFull">Use full image</button>
            <a href="#" id="resetCrop" class="tiny">Reset crop</a>
            <span class="muted" style="font-size:.9rem">Tip: drag anywhere on the image to redraw the box.</span>
          </div>
        </div>

        <!-- Progress + Errors -->
        <div id="progWrap" style="margin-top:12px;display:none">
          <div class="muted" style="font-weight:600;margin-bottom:6px">
            Reading text… <span id="pct">0</span>%
          </div>
          <div class="bar"><div id="bar"></div></div>
        </div>
        <div id="err" class="card bad" style="margin-top:12px;display:none"></div>
      </section>

      <!-- 2) Candidates + Manual -->
      <section class="card">
        <div style="display:flex;justify-content:space-between;gap:12px;align-items:center">
          <div>
            <h3 style="margin:.25rem 0">2) Candidates found</h3>
            <p class="muted" style="margin:0">Tap a number to open USPS in a new tab.</p>
          </div>
          <label class="switch">
            <input type="checkbox" id="autoOpen" checked />
            <span class="pill">Auto-open if only one</span>
          </label>
        </div>

        <div id="best" class="card good" style="margin-top:12px;display:none">
          <div class="muted" style="font-size:.75rem;font-weight:700;text-transform:uppercase;margin-bottom:4px">Best match</div>
          <div id="bestNum" class="mono" style="font-size:1.15rem;word-break:break-all"></div>
          <div style="margin-top:8px;display:flex;gap:8px">
            <button class="primary" id="openBest">Open on USPS</button>
            <button id="copyBest">Copy</button>
          </div>
        </div>

        <div id="many" class="list" style="margin-top:12px;display:grid;gap:8px"></div>

        <div class="card" style="margin-top:12px">
          <h4 style="margin:.25rem 0">Manual (paste or edit)</h4>
          <div style="display:flex;gap:8px;flex-wrap:wrap">
            <input id="manualInput" class="mono" placeholder="Paste tracking number…"
                   style="flex:1;min-width:220px;padding:10px;border:1px solid var(--line);border-radius:10px" />
            <button id="openManual" class="primary">Open on USPS</button>
          </div>
          <p class="muted" style="margin:.5rem 0 0">Tip: copy from “Raw OCR” if needed.</p>
        </div>
      </section>

      <!-- 3) Raw OCR -->
      <section class="card">
        <h3 style="margin:.25rem 0">3) Raw OCR (troubleshooting)</h3>
        <p class="muted" style="margin:0 0 6px">If this looks messy, try another angle or more light.</p>
        <textarea id="raw" readonly></textarea>
      </section>

      <section class="muted" style="font-size:.9rem">
        <p><strong>Tips:</strong> Avoid glare; tilt slightly if needed. Everything runs locally—no images are uploaded.</p>
      </section>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <script>
    // Elements
    const fileSnap   = document.getElementById('fileSnap');
    const fileUpload = document.getElementById('fileUpload');
    const snapBtn    = document.getElementById('snapBtn');
    const uploadBtn  = document.getElementById('uploadBtn');

    const previewWrap= document.getElementById('previewWrap');
    const canvas     = document.getElementById('canvas');
    const ctx        = canvas.getContext('2d');

    const progWrap   = document.getElementById('progWrap');
    const pct        = document.getElementById('pct');
    const bar        = document.getElementById('bar');
    const err        = document.getElementById('err');

    const rawOut     = document.getElementById('raw');
    const many       = document.getElementById('many');
    const bestBox    = document.getElementById('best');
    const bestNum    = document.getElementById('bestNum');
    const openBest   = document.getElementById('openBest');
    const copyBest   = document.getElementById('copyBest');
    const autoOpen   = document.getElementById('autoOpen');

    const useCropBtn = document.getElementById('useCrop');
    const useFullBtn = document.getElementById('useFull');
    const resetCrop  = document.getElementById('resetCrop');

    const manualInput = document.getElementById('manualInput');
    const openManual  = document.getElementById('openManual');

    // State
    let candidates = [];
    let best = null;

    let originalImg = null;  // ImageBitmap
    let displayScale = 1;    // canvas pixels per image pixel
    let cropRect = null;     // {x,y,w,h} in canvas coords
    let isDragging = false;

    // Events
    snapBtn.addEventListener('click',   () => fileSnap.click());
    uploadBtn.addEventListener('click', () => fileUpload.click());
    fileSnap.addEventListener('change', onFile);
    fileUpload.addEventListener('change', onFile);

    useCropBtn.addEventListener('click', async () => {
      if (!originalImg) return;
      const region = validCrop() ? cropFromCanvas() : makeDownscaledCanvas(originalImg);
      await ocrCanvas(region);
    });
    useFullBtn.addEventListener('click', async () => {
      if (!originalImg) return;
      await ocrCanvas(makeDownscaledCanvas(originalImg));
    });
    resetCrop.addEventListener('click', (e) => {
      e.preventDefault();
      if (!originalImg) return;
      setDefaultCrop();
      drawCanvas();
    });

    openBest.addEventListener('click', () => { if (best) openUSPS(best); });
    copyBest.addEventListener('click', async () => { if (best) await navigator.clipboard.writeText(best); });

    openManual.addEventListener('click', () => {
      const val = (manualInput.value || '').trim().toUpperCase();
      if (!val) return;
      const cleaned = /^[A-Z]{2}\d{9}US$/i.test(val) ? val : val.replace(/\D+/g,'');
      if (!cleaned) return;
      openUSPS(cleaned);
    });

    // File handling
    async function onFile(e){
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      resetUI();

      const url = URL.createObjectURL(f);
      try {
        originalImg = await createImageBitmap(await fetch(url).then(r=>r.blob()));
        setupCanvasForImage(originalImg);
        previewWrap.style.display = '';
      } catch(ex){
        err.textContent = 'Could not load image. Try another photo.';
        err.style.display = '';
      } finally {
        URL.revokeObjectURL(url);
      }
    }

    // Canvas / crop
    function setupCanvasForImage(img) {
      const maxW = Math.min(1200, Math.max(360, Math.floor(window.innerWidth - 40)));
      const scale = Math.min(1, maxW / img.width);
      canvas.width = Math.round(img.width * scale);
      canvas.height = Math.round(img.height * scale);
      displayScale = scale;

      setDefaultCrop();
      drawCanvas();
      attachCropEvents();
    }

    function setDefaultCrop(){
      // Default to a central horizontal strip (good for tracking lines):
      const w = Math.round(canvas.width * 0.92);
      const h = Math.round(canvas.height * 0.28);
      cropRect = {
        x: Math.round((canvas.width - w) / 2),
        y: Math.round((canvas.height - h) / 2),
        w, h
      };
    }

    function drawCanvas() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if (!originalImg) return;

  // Draw the photo
  ctx.drawImage(
    originalImg,
    0, 0,
    originalImg.width * displayScale,
    originalImg.height * displayScale
  );

  // Draw OUTLINE ONLY (no fill, no overlay)
  if (cropRect) {
    ctx.save();

    // High-contrast double stroke so it shows on any label
    // 1) dark under-stroke
    ctx.strokeStyle = 'rgba(0,0,0,0.9)';
    ctx.lineWidth = 5;
    ctx.strokeRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);

    // 2) white outline on top
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 3;
    ctx.strokeRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);

    // Corner ticks for better affordance
    const t = 14;
    const drawTick = (x1,y1,x2,y2,x3,y3) => {
      ctx.beginPath();
      ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.lineTo(x3,y3); ctx.stroke();
    };
    // dark ticks under
    ctx.strokeStyle = 'rgba(0,0,0,0.9)'; ctx.lineWidth = 5;
    drawTick(cropRect.x, cropRect.y+t, cropRect.x, cropRect.y, cropRect.x+t, cropRect.y);
    drawTick(cropRect.x+cropRect.w-t, cropRect.y, cropRect.x+cropRect.w, cropRect.y, cropRect.x+cropRect.w, cropRect.y+t);
    drawTick(cropRect.x, cropRect.y+cropRect.h-t, cropRect.x, cropRect.y+cropRect.h, cropRect.x+t, cropRect.y+cropRect.h);
    drawTick(cropRect.x+cropRect.w-t, cropRect.y+cropRect.h, cropRect.x+cropRect.w, cropRect.y+cropRect.h, cropRect.x+cropRect.w, cropRect.y+cropRect.h-t);
    // white ticks on top
    ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 3;
    drawTick(cropRect.x, cropRect.y+t, cropRect.x, cropRect.y, cropRect.x+t, cropRect.y);
    drawTick(cropRect.x+cropRect.w-t, cropRect.y, cropRect.x+cropRect.w, cropRect.y, cropRect.x+cropRect.w, cropRect.y+t);
    drawTick(cropRect.x, cropRect.y+cropRect.h-t, cropRect.x, cropRect.y+cropRect.h, cropRect.x+t, cropRect.y+cropRect.h);
    drawTick(cropRect.x+cropRect.w-t, cropRect.y+cropRect.h, cropRect.x+cropRect.w, cropRect.y+cropRect.h, cropRect.x+cropRect.w, cropRect.y+cropRect.h-t);

    ctx.restore();
  }
}

    function attachCropEvents(){
      canvas.onpointerdown = (ev) => {
        const {x,y} = canvasPoint(ev);
        cropRect = { x, y, w: 0, h: 0 };
        isDragging = true;
        canvas.setPointerCapture(ev.pointerId);
        drawCanvas();
      };
      canvas.onpointermove = (ev) => {
        if (!isDragging || !cropRect) return;
        const {x,y} = canvasPoint(ev);
        cropRect.w = x - cropRect.x;
        cropRect.h = y - cropRect.y;
        if (cropRect.w < 0) { cropRect.x += cropRect.w; cropRect.w *= -1; }
        if (cropRect.h < 0) { cropRect.y += cropRect.h; cropRect.h *= -1; }
        drawCanvas();
      };
      canvas.onpointerup = (ev) => {
        isDragging = false;
        canvas.releasePointerCapture(ev.pointerId);
        drawCanvas();
      };
    }

    function canvasPoint(ev){
      const r = canvas.getBoundingClientRect();
      const x = (ev.clientX - r.left) * (canvas.width / r.width);
      const y = (ev.clientY - r.top)  * (canvas.height / r.height);
      return { x: Math.max(0, Math.min(canvas.width,  x)),
               y: Math.max(0, Math.min(canvas.height, y)) };
    }

    function validCrop(){ return cropRect && cropRect.w >= 10 && cropRect.h >= 10; }

    // OCR
    async function ocrCanvas(srcCanvas){
      try {
        err.style.display = 'none';
        progWrap.style.display = '';
        pct.textContent = '0'; bar.style.width = '0%';

        const res = await Tesseract.recognize(srcCanvas, 'eng', {
          logger: m => {
            if (m.status === 'recognizing text' && typeof m.progress === 'number') {
              const p = Math.round(m.progress * 100);
              pct.textContent = String(p);
              bar.style.width = p + '%';
            }
          }
        });

        const text = (res.data.text || '');
        rawOut.value = text;

        candidates = extractUsps(text);
        renderCandidates();

        if (candidates.length === 1 && autoOpen.checked) openUSPS(candidates[0]);
      } catch(ex){
        err.textContent = 'OCR stumbled. Try a brighter, sharper photo that fills the label.';
        err.style.display = '';
      } finally {
        progWrap.style.display = 'none';
      }
    }

    // USPS + extraction (same logic as before)
    function openUSPS(n){
      const url = new URL('https://tools.usps.com/go/TrackConfirmAction');
      url.searchParams.set('tLabels', n);
      window.open(url.toString(), '_blank', 'noopener,noreferrer');
    }

    function human(n){
      if (/^[A-Z]{2}\d{9}US$/i.test(n)) return n.toUpperCase();
      return n.replace(/(\d{4})(?=\d)/g, '$1 ').trim();
    }

    function score(n){
      let s = 0; const L = n.length;
      if (L === 22) s += 6;
      else if (L === 20) s += 5;
      else if (L >= 26 && L <= 34) s += 2;
      if (/^(92|93|94)/.test(n)) s += 3;
      if (/^[A-Z]{2}\d{9}US$/i.test(n)) s += 7;
      return s;
    }

    function extractUsps(text){
      const cleaned = normalize(text);
      const intl = Array.from(cleaned.matchAll(/\b([A-Z]{2})\s*(\d{3})\s*(\d{3})\s*(\d{3})\s*(US)\b/gi))
        .map(m => (m[1] + m[2] + m[3] + m[4] + m[5]).toUpperCase());
      const longNums = Array.from(cleaned.matchAll(/((?:\d[\s-]?){20,34})/g))
        .map(m => m[0].replace(/[\s-]/g,''))
        .filter(n => [20,22,26,30,34].includes(n.length));
      const seen = new Set(), out = [];
      [...intl, ...longNums].forEach(n => { if(!seen.has(n)){ seen.add(n); out.push(n); }});
      return out;
    }

    function normalize(text){
      let t = (text || '').toUpperCase();
      t = t.replace(/(?<=\d|\s)O(?=\d|\s)/g,'0');
      t = t.replace(/(?<=\d|\s)[IL](?=\d|\s)/g,'1');
      t = t.replace(/(?<=\d|\s)S(?=\d|\s)/g,'5');
      t = t.replace(/(?<=\d|\s)B(?=\d|\s)/g,'8');
      t = t.replace(/(?<=\d|\s)Z(?=\d|\s)/g,'2');
      return t;
    }

    function cropFromCanvas(){
      const c = document.createElement('canvas');
      c.width = Math.round(cropRect.w);
      c.height = Math.round(cropRect.h);
      const cctx = c.getContext('2d');
      cctx.drawImage(canvas,
        Math.round(cropRect.x), Math.round(cropRect.y), Math.round(cropRect.w), Math.round(cropRect.h),
        0, 0, Math.round(cropRect.w), Math.round(cropRect.h)
      );
      return c;
    }

    function makeDownscaledCanvas(img, maxDim=1800){
      const scale = Math.min(1, maxDim / Math.max(img.width, img.height));
      const w = Math.round(img.width * scale), h = Math.round(img.height * scale);
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      const cctx = c.getContext('2d');
      cctx.drawImage(img, 0, 0, w, h);
      return c;
    }

    function resetUI(){
      err.style.display = 'none';
      many.innerHTML = '';
      bestBox.style.display = 'none';
      rawOut.value = '';
      candidates = [];
      best = null;
      cropRect = null;
      if (typeof drawCanvas === 'function') drawCanvas();
    }

    function renderCandidates(){
      if(!candidates.length){
        many.innerHTML = '<p class="muted" style="margin:0">No tracking numbers captured yet.</p>';
        many.style.display = '';
        return;
      }
      const scored = candidates.map(n => ({n, score: score(n)})).sort((a,b)=>b.score-a.score);
      best = scored[0].n;

      bestNum.textContent = human(best);
      bestBox.style.display = '';
      manualInput.value = best;

      if(candidates.length > 1){
        many.style.display = 'grid';
        many.innerHTML = '';
        candidates.forEach((n) => {
          const b = document.createElement('button');
          b.className = 'card';
          b.textContent = human(n);
          b.onclick = () => openUSPS(n);
          many.appendChild(b);
        });
      } else {
        many.style.display = 'none';
      }
    }
  </script>
</body>
</html>
