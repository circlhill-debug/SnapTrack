<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>SnapTrack — USPS OCR</title>

  <style>
    :root{--ink:#111;--muted:#6b7280;--line:#e5e7eb;--bg:#f8fafc}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial}
    .wrap{max-width:720px;margin:0 auto;padding:20px}
    h1{font-size:1.75rem;margin:0 0 .25rem}
    p{margin:.25rem 0}
    .card{background:#fff;border:1px solid var(--line);border-radius:16px;padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
    button{cursor:pointer;border:1px solid #d1d5db;background:#fff;padding:10px 14px;border-radius:12px}
    button.primary{background:#111;color:#fff;border-color:#111}
    button:active{transform:scale(.99)}
    .muted{color:var(--muted)}
    .grid{display:grid;gap:16px}
    .img{width:100%;border:1px solid var(--line);border-radius:12px;touch-action:none}
    .bar{height:8px;border-radius:999px;background:#eef2f7;overflow:hidden}
    .bar>div{height:100%;background:#111;width:0%}
    textarea{width:100%;height:150px;border:1px solid var(--line);border-radius:12px;padding:10px;background:#f7f7f8;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;font-size:.9rem}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
    .pill{display:inline-block;font-size:.75rem;padding:.25rem .5rem;border-radius:999px;border:1px solid #d1d5db}
    label.switch{display:flex;align-items:center;gap:.5rem;font-size:.9rem}
    .list > button{width:100%;text-align:left}
    .good{background:#ecfdf5;border-color:#a7f3d0}
    .bad{background:#fef2f2;border-color:#fecaca;color:#b91c1c}
    .zoombar{position:absolute;top:12px;right:12px;display:flex;gap:6px}
    .zoombar button{padding:8px 10px;border-radius:10px}
    .relative{position:relative}
    footer{margin-top:16px;color:#6b7280;font-size:.85rem;text-align:center}
  </style>
</head>
<body>
  <div class="wrap">
    <header style="margin-bottom:16px">
      <h1>SnapTrack — USPS OCR</h1>
      <p class="muted">Two-finger **pinch to zoom** and **drag with two fingers to pan**. One finger moves/resizes the crop box. Then tap <em>Use crop</em>.</p>
    </header>

    <div class="grid">
      <!-- 1) Capture / Upload -->
      <section class="card">
        <div style="display:flex;justify-content:space-between;gap:12px;align-items:center;flex-wrap:wrap">
          <div>
            <h3 style="margin:.25rem 0">1) Take or upload a photo</h3>
            <p class="muted" style="margin:0">Rear camera in good light; fill the frame. Or upload and crop first.</p>
          </div>
          <div style="display:flex;gap:8px;flex-wrap:wrap">
            <button id="snapBtn">Snap (Camera)</button>
            <button id="uploadBtn">Upload from Photos</button>
          </div>
        </div>

        <input id="fileSnap"   type="file" accept="image/*" capture="environment" style="display:none" />
        <input id="fileUpload" type="file" accept="image/*" style="display:none" />

        <!-- Preview + Crop UI -->
        <div id="previewWrap" style="margin-top:12px;display:none">
          <div class="relative">
            <canvas id="canvas" class="img"></canvas>
            <div class="zoombar" aria-hidden="true">
              <button id="zoomOut" title="Zoom out">−</button>
              <button id="zoomReset" title="Reset zoom">100%</button>
              <button id="zoomIn" title="Zoom in">+</button>
            </div>
          </div>
          <div style="display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; align-items:center">
            <button id="useCrop" class="primary">Use crop</button>
            <button id="useFull">Use full image</button>
            <span class="muted" style="font-size:.9rem">Tip: pinch to zoom for precise cropping.</span>
          </div>
        </div>

        <!-- Progress + Errors -->
        <div id="progWrap" style="margin-top:12px;display:none">
          <div class="muted" style="font-weight:600;margin-bottom:6px">
            Reading text… <span id="pct">0</span>%
          </div>
          <div class="bar"><div id="bar"></div></div>
        </div>
        <div id="err" class="card bad" style="margin-top:12px;display:none"></div>
      </section>

      <!-- 2) Candidates + Manual -->
      <section class="card">
        <div style="display:flex;justify-content:space-between;gap:12px;align-items:center">
          <div>
            <h3 style="margin:.25rem 0">2) Candidates found</h3>
            <p class="muted" style="margin:0">Tap a number to open USPS in a new tab.</p>
          </div>
          <label class="switch">
            <input type="checkbox" id="autoOpen" checked />
            <span class="pill">Auto-open if only one</span>
          </label>
        </div>

        <div id="best" class="card good" style="margin-top:12px;display:none">
          <div class="muted" style="font-size:.75rem;font-weight:700;text-transform:uppercase;margin-bottom:4px">Best match</div>
          <div id="bestNum" class="mono" style="font-size:1.15rem;word-break:break-all"></div>
          <div style="margin-top:8px;display:flex;gap:8px">
            <button class="primary" id="openBest">Open on USPS</button>
            <button id="copyBest">Copy</button>
          </div>
        </div>

        <div id="many" class="list" style="margin-top:12px;display:grid;gap:8px"></div>

        <!-- Manual Paste Box -->
        <div class="card" style="margin-top:12px">
          <h4 style="margin:.25rem 0">Manual (paste or edit)</h4>
          <div style="display:flex;gap:8px;flex-wrap:wrap">
            <input id="manualInput" class="mono" placeholder="Paste tracking number…"
                   style="flex:1;min-width:220px;padding:10px;border:1px solid var(--line);border-radius:10px" />
            <button id="openManual" class="primary">Open on USPS</button>
          </div>
          <p class="muted" style="margin:.5rem 0 0">Tip: copy from “Raw OCR” if needed.</p>
        </div>
      </section>

      <!-- 3) Raw OCR -->
      <section class="card">
        <h3 style="margin:.25rem 0">3) Raw OCR (troubleshooting)</h3>
        <p class="muted" style="margin:0 0 6px">If this looks messy, try another angle or more light.</p>
        <textarea id="raw" readonly></textarea>
      </section>

      <section class="muted" style="font-size:.9rem">
        <p><strong>Tips:</strong> Avoid glare; tilt slightly if needed. Everything runs locally—no images are uploaded.</p>
      </section>

      <footer>
        © 2025 Dave — SnapTrack v2.0 • Built for USPS label OCR
      </footer>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <script>
    // Version
    const SNAPTRACK_VERSION = "v2.0 (2025-08-25)";

    // ===== Elements =====
    const fileSnap   = document.getElementById('fileSnap');
    const fileUpload = document.getElementById('fileUpload');
    const snapBtn    = document.getElementById('snapBtn');
    const uploadBtn  = document.getElementById('uploadBtn');

    const previewWrap= document.getElementById('previewWrap');
    const canvas     = document.getElementById('canvas');
    const ctx        = canvas.getContext('2d');

    const progWrap   = document.getElementById('progWrap');
    const pct        = document.getElementById('pct');
    const bar        = document.getElementById('bar');
    const err        = document.getElementById('err');

    const rawOut     = document.getElementById('raw');
    const many       = document.getElementById('many');
    const bestBox    = document.getElementById('best');
    const bestNum    = document.getElementById('bestNum');
    const openBest   = document.getElementById('openBest');
    const copyBest   = document.getElementById('copyBest');
    const autoOpen   = document.getElementById('autoOpen');

    const useCropBtn = document.getElementById('useCrop');
    const useFullBtn = document.getElementById('useFull');

    const manualInput = document.getElementById('manualInput');
    const openManual  = document.getElementById('openManual');

    // Zoom UI
    const zoomInBtn   = document.getElementById('zoomIn');
    const zoomOutBtn  = document.getElementById('zoomOut');
    const zoomResetBtn= document.getElementById('zoomReset');

    // ===== Config / State =====
    const HANDLE    = 20;     // crop handle size (px) — tweak as you like
    const EDGE_HIT  = 18;     // edge hit zone thickness (px)
    const MIN_W = 20, MIN_H = 20;

    const MIN_ZOOM = 0.6;
    const MAX_ZOOM = 4.0;

    let candidates = [];
    let best = null;

    let originalImg = null;            // HTMLImageElement
    let baseScale = 1;                 // canvas px per original px at zoom=1
    let zoom = 1;                      // pinch zoom factor
    let panX = 0, panY = 0;            // image top-left in canvas coords (after zoom)
    let cropRect = null;               // in canvas coords
    let isDragging = false;
    let dragMode = null;               // 'move' | 'nw'|'ne'|'se'|'sw'|'n'|'s'|'w'|'e' | null
    let dragStart = null;              // {x,y}
    let startRect = null;              // snapshot of crop rect

    // Pinch state
    const activePointers = new Map();  // id -> {x,y}
    let pinchStart = null;             // {dist, mid:{x,y}, zoom, panX, panY}

    // ===== Events: file inputs =====
    snapBtn.addEventListener('click',   () => fileSnap.click());
    uploadBtn.addEventListener('click', () => fileUpload.click());
    fileSnap.addEventListener('change', onFile);
    fileUpload.addEventListener('change', onFile);

    useCropBtn.addEventListener('click', async () => {
      if (!originalImg) return;
      const region = validCrop() ? cropFromCanvas() : makeDownscaledCanvas(originalImg);
      await ocrCanvas(region);
    });
    useFullBtn.addEventListener('click', async () => {
      if (!originalImg) return;
      await ocrCanvas(makeDownscaledCanvas(originalImg));
    });

    openBest.addEventListener('click', () => { if (best) openUSPS(best); });
    copyBest.addEventListener('click', async () => { if (best) await navigator.clipboard.writeText(best); });

    openManual.addEventListener('click', () => {
      const val = (manualInput.value || '').trim().toUpperCase();
      if (!val) return;
      const cleaned = /^[A-Z]{2}\d{9}US$/i.test(val) ? val : val.replace(/\D+/g,'');
      if (!cleaned) return;
      openUSPS(cleaned);
    });

    // Zoom buttons
    zoomInBtn.addEventListener('click',  () => zoomAround(canvas.width/2, canvas.height/2, 1.2));
    zoomOutBtn.addEventListener('click', () => zoomAround(canvas.width/2, canvas.height/2, 1/1.2));
    zoomResetBtn.addEventListener('click', () => setZoom(1, canvas.width/2, canvas.height/2));

    // ===== File handling =====
    async function onFile(e){
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      resetUI();

      const url = URL.createObjectURL(f);
      try {
        originalImg = await loadImage(url);
        setupCanvasForImage(originalImg);
        previewWrap.style.display = '';
      } catch(ex){
        err.textContent = 'Could not load image. Try another photo.';
        err.style.display = '';
      } finally {
        URL.revokeObjectURL(url);
      }
    }

    function loadImage(src){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }

    // ===== Canvas / layout =====
    function setupCanvasForImage(img) {
      const maxW = Math.min(1200, Math.max(360, Math.floor(window.innerWidth - 40)));
      const scale = Math.min(1, maxW / img.naturalWidth);
      canvas.width = Math.round(img.naturalWidth * scale);
      canvas.height = Math.round(img.naturalHeight * scale);
      baseScale = scale;

      // Reset view
      zoom = 1;
      // center the image
      panX = Math.round((canvas.width  - img.naturalWidth * baseScale * zoom) / 2);
      panY = Math.round((canvas.height - img.naturalHeight* baseScale * zoom) / 2);

      setDefaultCrop();
      drawCanvas();
      attachEvents();
      updateZoomLabel();
    }

    function setDefaultCrop(){
      const viewW = originalImg.naturalWidth * baseScale * zoom;
      const viewH = originalImg.naturalHeight* baseScale * zoom;
      const x0 = Math.round((canvas.width  - viewW) / 2 + viewW*0.04);
      const y0 = Math.round((canvas.height - viewH) / 2 + viewH*0.36);
      const w  = Math.round(viewW * 0.92);
      const h  = Math.round(viewH * 0.28);
      cropRect = { x: x0, y: y0, w, h };
    }

    // ===== Rendering =====
    function drawCanvas() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (!originalImg) return;

      const drawW = originalImg.naturalWidth * baseScale * zoom;
      const drawH = originalImg.naturalHeight* baseScale * zoom;

      // Image (with pan + zoom)
      ctx.drawImage(originalImg, panX, panY, drawW, drawH);

      // Crop box
      if (cropRect) {
        ctx.save();
        // dark stroke under white stroke (visible on bright/dark images)
        ctx.strokeStyle = 'rgba(0,0,0,0.9)';
        ctx.lineWidth = 5;
        ctx.strokeRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.strokeRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);

        // handles
        for (const h of handlePositions(cropRect)) {
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(h.x - HANDLE/2, h.y - HANDLE/2, HANDLE, HANDLE);
          ctx.strokeStyle = 'rgba(0,0,0,0.9)';
          ctx.lineWidth = 2.5;
          ctx.strokeRect(h.x - HANDLE/2, h.y - HANDLE/2, HANDLE, HANDLE);
        }
        ctx.restore();
      }
    }

    function handlePositions(r){
      const cx = r.x + r.w/2, cy = r.y + r.h/2;
      return [
        {name:'nw', x:r.x,       y:r.y},
        {name:'n',  x:cx,        y:r.y},
        {name:'ne', x:r.x+r.w,   y:r.y},
        {name:'e',  x:r.x+r.w,   y:cy},
        {name:'se', x:r.x+r.w,   y:r.y+r.h},
        {name:'s',  x:cx,        y:r.y+r.h},
        {name:'sw', x:r.x,       y:r.y+r.h},
        {name:'w',  x:r.x,       y:cy},
      ];
    }

    // ===== Interaction =====
    function attachEvents(){
      // Pointer/pinch on the canvas
      canvas.onpointerdown = (ev) => {
        ev.preventDefault();
        canvas.setPointerCapture(ev.pointerId);
        activePointers.set(ev.pointerId, canvasPoint(ev));

        if (activePointers.size >= 2) {
          // start pinch gesture
          pinchStart = getPinchState();
          // while pinching, do NOT start crop dragging
          isDragging = false;
          dragMode = null;
          return;
        }

        // single finger: crop interaction
        const p = activePointers.get(ev.pointerId);
        dragStart = p;
        startRect = cropRect ? {...cropRect} : null;
        const hit = hitTest(p, cropRect);
        if (hit) {
          dragMode = hit; isDragging = true;
        } else {
          dragMode = null; isDragging = false;
        }
        drawCanvas();
      };

      canvas.onpointermove = (ev) => {
        ev.preventDefault();
        if (!activePointers.has(ev.pointerId)) return;
        activePointers.set(ev.pointerId, canvasPoint(ev));

        if (activePointers.size >= 2) {
          // Pinch zoom/pan
          const pin = getPinchState();
          if (!pinchStart) pinchStart = pin;

          const scaleFactor = pin.dist / pinchStart.dist;
          const newZoom = clamp(MIN_ZOOM, pinchStart.zoom * scaleFactor, MAX_ZOOM);

          // keep the image point under the initial midpoint fixed
          const scale0 = baseScale * pinchStart.zoom;
          const scaleN = baseScale * newZoom;
          const ptImageX = (pinchStart.mid.x - pinchStart.panX) / scale0;
          const ptImageY = (pinchStart.mid.y - pinchStart.panY) / scale0;

          zoom = newZoom;
          panX = pin.mid.x - ptImageX * scaleN;
          panY = pin.mid.y - ptImageY * scaleN;

          clampPan();
          updateZoomLabel();
          drawCanvas();
          return;
        }

        // Single-finger crop drag/resize
        if (!isDragging || !cropRect || !dragMode) return;
        const p = activePointers.get(ev.pointerId);
        const dx = p.x - dragStart.x;
        const dy = p.y - dragStart.y;

        if (dragMode === 'move' && startRect) {
          cropRect.x = startRect.x + dx;
          cropRect.y = startRect.y + dy;
        } else if (startRect) {
          resizeFromHandle(dragMode, startRect, dx, dy);
        }

        clampCropWithinImage();
        drawCanvas();
      };

      canvas.onpointerup = (ev) => {
        ev.preventDefault();
        activePointers.delete(ev.pointerId);
        if (activePointers.size < 2) pinchStart = null;
        isDragging = false;
        dragMode = null;
        canvas.releasePointerCapture(ev.pointerId);
        drawCanvas();
      };

      canvas.onpointercancel = canvas.onpointerup;
    }

    // Edge/corner hit tests for crop
    function hitTest(p, r){
      if (!r) return null;
      // corners first
      for (const h of handlePositions(r)) {
        if (Math.abs(p.x - h.x) <= HANDLE/2 && Math.abs(p.y - h.y) <= HANDLE/2) return h.name;
      }
      // edges (exclude corners)
      const leftZone   = (p.x >= r.x - EDGE_HIT && p.x <= r.x + EDGE_HIT && p.y >= r.y + HANDLE/2 && p.y <= r.y + r.h - HANDLE/2);
      const rightZone  = (p.x >= r.x + r.w - EDGE_HIT && p.x <= r.x + r.w + EDGE_HIT && p.y >= r.y + HANDLE/2 && p.y <= r.y + r.h - HANDLE/2);
      const topZone    = (p.y >= r.y - EDGE_HIT && p.y <= r.y + EDGE_HIT && p.x >= r.x + HANDLE/2 && p.x <= r.x + r.w - HANDLE/2);
      const bottomZone = (p.y >= r.y + r.h - EDGE_HIT && p.y <= r.y + r.h + EDGE_HIT && p.x >= r.x + HANDLE/2 && p.x <= r.x + r.w - HANDLE/2);
      if (leftZone)   return 'w';
      if (rightZone)  return 'e';
      if (topZone)    return 'n';
      if (bottomZone) return 's';
      // inside rect → move
      if (p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h) return 'move';
      return null;
    }

    function resizeFromHandle(mode, r0, dx, dy){
      let x = r0.x, y = r0.y, w = r0.w, h = r0.h;
      const left   = () => { x = r0.x + dx; w = r0.w - dx; };
      const right  = () => { w = r0.w + dx; };
      const top    = () => { y = r0.y + dy; h = r0.h - dy; };
      const bottom = () => { h = r0.h + dy; };

      if (mode.includes('w')) left();
      if (mode.includes('e')) right();
      if (mode.includes('n')) top();
      if (mode.includes('s')) bottom();

      // min size
      if (w < MIN_W) { w = MIN_W; x = r0.x + (r0.w - w) * (mode.includes('w') ? 1 : 0); }
      if (h < MIN_H) { h = MIN_H; y = r0.y + (r0.h - h) * (mode.includes('n') ? 1 : 0); }

      cropRect = { x: Math.round(x), y: Math.round(y), w: Math.round(w), h: Math.round(h) };
    }

    function clampPan(){
      // Keep image roughly covering canvas; allow slight overscroll
      const drawW = originalImg.naturalWidth * baseScale * zoom;
      const drawH = originalImg.naturalHeight* baseScale * zoom;
      const minX = Math.min(0, canvas.width - drawW);
      const minY = Math.min(0, canvas.height - drawH);
      const maxX = Math.max(0, canvas.width - drawW);
      const maxY = Math.max(0, canvas.height - drawH);
      panX = clamp(minX, panX, maxX);
      panY = clamp(minY, panY, maxY);
    }

    function clampCropWithinImage(){
      const drawW = originalImg.naturalWidth * baseScale * zoom;
      const drawH = originalImg.naturalHeight* baseScale * zoom;
      const imgRect = { x: panX, y: panY, w: drawW, h: drawH };

      // Clamp cropRect to within the drawn image rect
      if (cropRect.w > imgRect.w) cropRect.w = imgRect.w;
      if (cropRect.h > imgRect.h) cropRect.h = imgRect.h;

      if (cropRect.x < imgRect.x) cropRect.x = imgRect.x;
      if (cropRect.y < imgRect.y) cropRect.y = imgRect.y;
      if (cropRect.x + cropRect.w > imgRect.x + imgRect.w) cropRect.x = imgRect.x + imgRect.w - cropRect.w;
      if (cropRect.y + cropRect.h > imgRect.y + imgRect.h) cropRect.y = imgRect.y + imgRect.h - cropRect.h;

      // Enforce min size after clamping
      if (cropRect.w < MIN_W) cropRect.w = MIN_W;
      if (cropRect.h < MIN_H) cropRect.h = MIN_H;
    }

    // ===== Utilities =====
    function clamp(min, v, max){ return Math.max(min, Math.min(max, v)); }

    function canvasPoint(ev){
      const r = canvas.getBoundingClientRect();
      const x = (ev.clientX - r.left) * (canvas.width / r.width);
      const y = (ev.clientY - r.top)  * (canvas.height / r.height);
      return { x: Math.max(0, Math.min(canvas.width,  x)),
               y: Math.max(0, Math.min(canvas.height, y)) };
    }

    function getPinchState(){
      const ids = Array.from(activePointers.keys());
      const p1 = activePointers.get(ids[0]);
      const p2 = activePointers.get(ids[1]);
      const dx = p2.x - p1.x, dy = p2.y - p1.y;
      const dist = Math.hypot(dx, dy) || 1;
      const mid = { x: (p1.x + p2.x)/2, y: (p1.y + p2.y)/2 };
      return { dist, mid, zoom, panX, panY };
    }

    function setZoom(newZoom, focusX, focusY){
      const z = clamp(MIN_ZOOM, newZoom, MAX_ZOOM);
      const scale0 = baseScale * zoom;
      const scaleN = baseScale * z;
      // keep point under focus stable
      const ptImageX = (focusX - panX) / scale0;
      const ptImageY = (focusY - panY) / scale0;
      zoom = z;
      panX = focusX - ptImageX * scaleN;
      panY = focusY - ptImageY * scaleN;
      clampPan();
      updateZoomLabel();
      drawCanvas();
    }

    function zoomAround(cx, cy, factor){
      setZoom(zoom * factor, cx, cy);
    }

    function updateZoomLabel(){
      if (!zoomResetBtn) return;
      zoomResetBtn.textContent = Math.round(zoom * 100) + '%';
    }

    // ===== OCR pipeline (same as v1.9; BW threshold is in applyThresholdToCanvas) =====
    const THRESHOLD = 128; // tweak 110–150 if needed for backlit screens

    function applyThresholdToCanvas(c){
      const cctx = c.getContext('2d', { willReadFrequently: true });
      const imgData = cctx.getImageData(0, 0, c.width, c.height);
      const d = imgData.data;
      for (let i = 0; i < d.length; i += 4) {
        const r = d[i], g = d[i+1], b = d[i+2];
        const gray = 0.299*r + 0.587*g + 0.114*b;
        const bw = gray > THRESHOLD ? 255 : 0;
        d[i] = d[i+1] = d[i+2] = bw;
      }
      cctx.putImageData(imgData, 0, 0);
    }

    // Crop mapped to ORIGINAL image (accounts for pan + zoom)
    function cropFromCanvas(){
      const scaleAll = baseScale * zoom;
      // Convert cropRect (canvas) -> original image pixels
      const srcX = Math.max(0, Math.round((cropRect.x - panX) / scaleAll));
      const srcY = Math.max(0, Math.round((cropRect.y - panY) / scaleAll));
      const srcW = Math.max(1, Math.round(cropRect.w / scaleAll));
      const srcH = Math.max(1, Math.round(cropRect.h / scaleAll));

      const c = document.createElement('canvas');
      c.width = srcW;
      c.height = srcH;
      const cctx = c.getContext('2d');
      cctx.drawImage(originalImg, srcX, srcY, srcW, srcH, 0, 0, srcW, srcH);

      applyThresholdToCanvas(c);
      return c;
    }

    // Full image downscale + threshold
    function makeDownscaledCanvas(img, maxDim=1800){
      const w0 = img.naturalWidth, h0 = img.naturalHeight;
      const scale = Math.min(1, maxDim / Math.max(w0, h0));
      const w = Math.round(w0 * scale), h = Math.round(h0 * scale);
      const c = document.createElement('canvas');
      c.width = w; c.height = h;
      const cctx = c.getContext('2d');
      cctx.drawImage(img, 0, 0, w, h);
      applyThresholdToCanvas(c);
      return c;
    }

    async function ocrCanvas(srcCanvas){
      try {
        err.style.display = 'none';
        progWrap.style.display = '';
        pct.textContent = '0'; bar.style.width = '0%';

        const res = await Tesseract.recognize(srcCanvas, 'eng', {
          logger: m => {
            if (m.status === 'recognizing text' && typeof m.progress === 'number') {
              const p = Math.round(m.progress * 100);
              pct.textContent = String(p);
              bar.style.width = p + '%';
            }
          }
        });

        const text = (res.data.text || '');
        rawOut.value = text;

        candidates = extractUsps(text);
        renderCandidates();

        if (candidates.length === 1 && autoOpen.checked) openUSPS(candidates[0]);
      } catch(ex){
        console.error('Tesseract error:', ex);
        err.textContent = 'OCR stumbled. Try a brighter, sharper photo that fills the label.';
        err.style.display = '';
      } finally {
        progWrap.style.display = 'none';
      }
    }

    // ===== USPS helpers =====
    function openUSPS(n){
      const url = new URL('https://tools.usps.com/go/TrackConfirmAction');
      url.searchParams.set('tLabels', n);
      window.open(url.toString(), '_blank', 'noopener,noreferrer');
    }

    function human(n){
      if (/^[A-Z]{2}\d{9}US$/i.test(n)) return n.toUpperCase();
      return n.replace(/(\d{4})(?=\d)/g, '$1 ').trim();
    }

    function score(n){
      let s = 0; const L = n.length;
      if (L === 22) s += 6;
      else if (L === 20) s += 5;
      else if (L >= 26 && L <= 34) s += 2;
      if (/^(92|93|94)/.test(n)) s += 3;
      if (/^[A-Z]{2}\d{9}US$/i.test(n)) s += 7;
      return s;
    }

    function extractUsps(text){
      const cleaned = normalize(text);
      const intl = Array.from(cleaned.matchAll(/\b([A-Z]{2})\s*(\d{3})\s*(\d{3})\s*(\d{3})\s*(US)\b/gi))
        .map(m => (m[1] + m[2] + m[3] + m[4] + m[5]).toUpperCase());
      const longNums = Array.from(cleaned.matchAll(/((?:\d[\s-]?){20,34})/g))
        .map(m => m[0].replace(/[\s-]/g,''))
        .filter(n => [20,22,26,30,34].includes(n.length));
      const seen = new Set(), out = [];
      [...intl, ...longNums].forEach(n => { if(!seen.has(n)){ seen.add(n); out.push(n); }});
      return out;
    }

    function normalize(text){
      let t = (text || '').toUpperCase();
      t = t.replace(/(?<=\d|\s)O(?=\d|\s)/g,'0');
      t = t.replace(/(?<=\d|\s)[IL](?=\d|\s)/g,'1');
      t = t.replace(/(?<=\d|\s)S(?=\d|\s)/g,'5');
      t = t.replace(/(?<=\d|\s)B(?=\d|\s)/g,'8');
      t = t.replace(/(?<=\d|\s)Z(?=\d|\s)/g,'2');
      return t;
    }

    function resetUI(){
      err.style.display = 'none';
      many.innerHTML = '';
      bestBox.style.display = 'none';
      rawOut.value = '';
      candidates = [];
      best = null;

      // keep current zoom/pan unless new image loaded
      cropRect = null;
      dragMode = null;
      drawCanvas();
    }

    function renderCandidates(){
      if(!candidates.length){
        many.innerHTML = '<p class="muted" style="margin:0">No tracking numbers captured yet.</p>';
        many.style.display = '';
        return;
      }
      const scored = candidates.map(n => ({n, score: score(n)})).sort((a,b)=>b.score-a.score);
      best = scored[0].n;

      bestNum.textContent = human(best);
      bestBox.style.display = '';
      manualInput.value = best;

      if(candidates.length > 1){
        many.style.display = 'grid';
        many.innerHTML = '';
        candidates.forEach((n) => {
          const b = document.createElement('button');
          b.className = 'card';
          b.textContent = human(n);
          b.onclick = () => openUSPS(n);
          many.appendChild(b);
        });
      } else {
        many.style.display = 'none';
      }
    }
  </script>

  <!--
  MIT License (ok to also add as LICENSE file in repo)

  Copyright (c) 2025 Dave

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
  -->
</body>
</html>
